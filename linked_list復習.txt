Linuxカーネルで、最も一般的に使用される2つのデータ構造は、Linked Listと、Red-Black Treeだ。


リンクリストは、array[]を動的に展開できないという欠点を、解決するためのデータ構造で、要素のノードは、動的に作成、挿入、削除ができる。
また、各要素は、バラバラ保存されるため、連続メモリを占有する必要がない。
通常複数のノードで構成され、各ノードの構造は同じで、有効データ領域とポインタ領域の2つの部分で構成される。

	------> Linux kernelは、ポインター領域だけにした、理由は後で。



--------------------------------------------------------------------------------
一般的なLinked List(密結合)と、その欠点
--------------------------------------------------------------------------------
以下のコードを例として、一般的なList構造について説明します。

(1)単一List

	struct list {
		unsigned int data;
		struct list *next;
	};
	
	Linkさせた図は、以下:

        .------------------------.
        |          head          |
        '-----------+------------'
	           /
	          /  list                           list                            list                           list
	   .-----+------------------.     ..------------------------.      .------------------------.     .------------------------.     .------------------------.
	   |    unsigned int data   |    / |    unsigned int data   |     /|   unsigned int data    |    /|   unsigned int data    |    /|          NULL          |
	   |                        |   /  |                        |    / |                        |   / |                        |   / |                        |
	   |------------------------|  /   |------------------------|   /  |------------------------|  /  |------------------------|  /  '------------------------'
	   |                        | /    |                        |  /   |                        | /   |                        | /   
	   |    struct list *next   -'     |    struct list *next   |-'    |    struct list *next   -'    |    struct list *next   |'    
	   '------------------------'      '------------------------'      '------------------------'     '------------------------'      


(2)二重List

	struct list {
		unsigned int data;
		struct list *prev;
		struct list *next;
	};
	
欠点:
	intメンバーの代わりに、char [10]に変えたら、List操作API群も、再実装が必要だ。
	この点が、密結合のLink構造の欠点と言える。




--------------------------------------------------------------------------------
Linux Linked List(粗結合)
--------------------------------------------------------------------------------
粗結合:
	Kernelのlistノードには、ポインタ領域のみがあり、データ領域がない:

		struct list_head {			//<include/linux/types.h>
			struct list_head *next, *prev;
		};                                

	利点は、データ構造(構造体)に応じて、List操作API群を再実装する必要性が無い事だ。
	データ領域がないので、struct list_headは、他データ構造の中に入れて、使う。 
	その上で、ノード作成、ノード挿入、ノード削除、ノードSCANなど、一連の操作API群も実装した。
	即ち、粗結合の状態だ:

		struct my_list {
			int data1;
			int data2;
			struct list_head list;
		};

	* list_head は、データ構造全体のアドレスではなく、メンバー list_head のアドレスを指す。

list_head使い方:

                                                   Node 0                                Node 1                                Node 2
                                        .-----------------------------.      .-----------------------------.       .-----------------------------.
                                        |      .-----------.          |      |        .-----------.        |       |       .-----------.         |
                                        |      | int data1 |          |      |        | int data1 |        |       |       | int data1 |         |
                                        |      '-----------'          |      |        '-----------'        |       |       '-----------'         |
                      .-----------------.      .-----------.          |      |        .-----------.        |       |       .-----------.         |
                      |                 |\     | int data2 |          |      |        | int data2 |        |       |       | int data2 |         |
                      |                 | \    '-----------'          |      |        '-----------'        |       |       '-----------'         |
              Head    v                 |  \           .------------------------.            .------------------------.                          |
          .----------------------.      |  .\----------v----------.   |      |   \-----------v----------.  |       |   \----------------------.  |
          |   struct list_head   |      |  | \ struct list_head   |   |      |   |\  struct list_head   |  |       |   |\  struct list_head   |  |
          | .------.   .------.  |      |  |  '------.   .------. |   |      |   | '------.    .------. |  |       |   | '------.  .------.   |  |
    .---->| | prev |   | next |----------->|  | prev |   | next |--------------->| | prev |    | next |--------------->| | prev |  | next |   |  |
    |     | '------'   '------'  |      |  |  '------'   '------' |   |      |   | '------'    '------' |  |       |   | '------'  '------'   |  |
    |     '-----|----------------'      |  '----------------------'   |      |   '----------------------'  |       |   '---------------|------'  |
    |           |                       |                             |      |                             |       |               ^   |         |
    |           |                       '-----------------------------'      '-----------------------------'       '---------------|---|---------'
    |           |                                                                                                                  |   |
    +-----------|------------------------------------------------------------------------------------------------------------------|---'
                '------------------------------------------------------------------------------------------------------------------+



--------------------------------------------------------------------------------
listの初期化---動的
--------------------------------------------------------------------------------
INIT_LIST_HEAD マクロ

struct list_head	my_list;	//定義
INIT_LIST_HEAD( &my_list );		//動的初期化

	drivers/media/v4l2-core/v4l2-subdev.c:	INIT_LIST_HEAD(&sd->list);
	drivers/media/v4l2-core/v4l2-async.c:	INIT_LIST_HEAD(&notifier->asd_list);
	drivers/media/v4l2-core/v4l2-async.c:	INIT_LIST_HEAD(&notifier->waiting);
	drivers/media/v4l2-core/v4l2-async.c:	INIT_LIST_HEAD(&notifier->done);
	drivers/media/v4l2-core/v4l2-async.c:	INIT_LIST_HEAD(&sd->async_list);
	drivers/media/v4l2-core/v4l2-device.c:	INIT_LIST_HEAD(&v4l2_dev->subdevs);
	drivers/media/v4l2-core/v4l2-ctrls.c:	INIT_LIST_HEAD(&hdl->ctrls);
	drivers/media/v4l2-core/v4l2-ctrls.c:	INIT_LIST_HEAD(&hdl->ctrl_refs);
	drivers/media/v4l2-core/v4l2-ctrls.c:	INIT_LIST_HEAD(&hdl->requests);
	drivers/media/v4l2-core/v4l2-ctrls.c:	INIT_LIST_HEAD(&hdl->requests_queued);
	drivers/media/v4l2-core/v4l2-ctrls.c:	INIT_LIST_HEAD(&ctrl->ev_subs);
	drivers/media/v4l2-core/v4l2-dev.c:	INIT_LIST_HEAD(&vdev->fh_list);


	//マクロ定義
	//このマクロは、list_head構造体のnextポインタ、prevポインタの指すアドレスを、初期化対象のlist_head構造体自身にしてる。
	//WRITE_ONCEマクロは、GCC最適化によってコードが意図せぬ結果にならないよう、実装段階で防止する。

	static inline void INIT_LIST_HEAD(struct list_head *list) 	//<include/linux/list.h>
	{                                                         
	    WRITE_ONCE(list->next, list);	                         
	    list->prev = list;                                    
	}


--------------------------------------------------------------------------------
listの初期化---静的
--------------------------------------------------------------------------------
LIST_HEAD マクロ

LIST_HEAD( my_list );		//静的初期化 (動的Listを初期化するマクロ　INIT_LIST_HEAD より、INIT_ が無い)

	//マクロ定義
	#define LIST_HEAD(name) \                        
	    struct list_head name = LIST_HEAD_INIT(name) 
	
	#define LIST_HEAD_INIT(name) { &(name), &(name) }

	//ex
	drivers/dma/stm32-mdma.c:	LIST_HEAD(head);
	drivers/dma/s3c24xx-dma.c:	LIST_HEAD(head);
	drivers/dma/tegra210-adma.c:	LIST_HEAD(head);
	drivers/dma/sf-pdma/sf-pdma.c:	LIST_HEAD(head);

--------------------------------------------------------------------------------
List構造に要素を追加
--------------------------------------------------------------------------------
<include/linux/list.h>

list_add     (struct list_head *new, struct list_head *head)	//引数1: 追加対象(list_head構造体)、引数2: 追加先。追加場所は、引数2で指定したList構造の次
list_add_tail(struct list_head *new, struct list_head *head)	//引数1: 追加対象(list_head構造体)、引数2: 追加先。追加場所は、引数2で指定したList構造の前(=Listの最後尾)

----------------------------------------
例:
----------------------------------------
LIST_HEAD(head);     		/* 要素の挿入先 */                                                                                  
LIST_HEAD(new_list);		/* 新たに追加したいList構造 */
list_add(&new_list, &head);	/* headの後ろにnew_listを連結(nodeらの中では、一番最初に挿入) */

	実行前:

                           .---------------------------------------------
                           |                                            |
               .-----------v-----------.                                |
               |         Head          |                                |
               | .-------.   .-------. |                                |
               | |       |   |       | |                                |
               | | prev  |   | next  |-------------------.              |
               | '-------'   '-------' |                 v              |
               '-----|-----------------'     .-----------------------.  |
                     |     ^                 |         Node1         |  |
                     |     |                 | .-------.   .-------. |  |
                     |     |                 | |       |   |       | |  |
                     |     '-------------------| prev  |   |  next |----'
                     |                       | '-------'   '-------' |
                     |                       '-----------------------'
                     |                                   ^
                     '-----------------------------------'

	実行後:

                           .--------------------------------------------------------------------------------------
                           v                                                                                     |
               .-----------------------.                                                                         |
               |         Head          |                                                                         |
               | .-------.   .-------. |                                                                         |
               | |       |   |       | |                                                                         |
               | | prev  |   | next  |------------------.                                                        |
               | '-------'   '-------' |                |                                                        |
               '-----|-----------------'                v                                                        |
                     |     ^                 .-----------------------.                                           |
                     |     |                 |        Node2          |                                           |
                     |     |                 | .-------.   .-------. |                                           |
                     |     |                 | |       |   |       | |                                           |
                     |     '-------------------|prev   |   |  next |-------------------------.                   |
                     |                       | '-------'   '-------' |                       |                   |
                     |                       '-----------------------'                       |                   |
                     |                                   ^                       .-----------v-----------.       |
                     |                                   |                       |         Node1         |       |
                     |                                   |                       | .-------.   .-------. |       |
                     |                                   |                       | |       |   |       | |       |
                     |                                   '-------------------------| prev  |   | next  |---------'
                     |                                                           | '-------'   '-------' |
                     |                                                           '-----------------------'
                     |                                                                       ^
                     |                                                                       |
                     '-----------------------------------------------------------------------+
	

----------------------------------------
例:
----------------------------------------
LIST_HEAD(head);		/* 要素の挿入先*/                                                                                  
LIST_HEAD(new_list);		/* 新たに追加したいList構造 */
LIST_HEAD(last_list);		/* 最後尾に追加したいList構造 */
 
list_add_tail(&new_list, &head);	/* headの後ろにnew_listを連結    */
list_add_tail(&last_list, &head);	/* headの最後尾にlast_listを連結 */


	実行前:

                           .---------------------------------------------
                           |                                            |
               .-----------v-----------.                                |
               |         Head          |                                |
               | .-------.   .-------. |                                |
               | |       |   |       | |                                |
               | | prev  |   | next  |-------------------.              |
               | '-------'   '-------' |                 v              |
               '-----|-----------------'     .-----------------------.  |
                     |     ^                 |         Node1         |  |
                     |     |                 | .-------.   .-------. |  |
                     |     |                 | |       |   |       | |  |
                     |     '-------------------| prev  |   |  next |----'
                     |                       | '-------'   '-------' |
                     |                       '-----------------------'
                     |                                   ^
                     '-----------------------------------'

	実行後:

                           .--------------------------------------------------------------------------------------
                           v                                                                                     |
               .-----------------------.                                                                         |
               |         Head          |                                                                         |
               | .-------.   .-------. |                                                                         |
               | |       |   |       | |                                                                         |
               | | prev  |   | next  |------------------.                                                        |
               | '-------'   '-------' |                |                                                        |
               '-----|-----------------'                v                                                        |
                     |     ^                 .-----------------------.                                           |
                     |     |                 |        Node1          |                                           |
                     |     |                 | .-------.   .-------. |                                           |
                     |     |                 | |       |   |       | |                                           |
                     |     '-------------------|prev   |   |  next |-------------------------.                   |
                     |                       | '-------'   '-------' |                       |                   |
                     |                       '-----------------------'                       |                   |
                     |                                   ^                       .-----------v-----------.       |
                     |                                   |                       |         Node2         |       |
                     |                                   |                       | .-------.   .-------. |       |
                     |                                   |                       | |       |   |       | |       |
                     |                                   '-------------------------| prev  |   | next  |---------'
                     |                                                           | '-------'   '-------' |
                     |                                                           '-----------------------'
                     |                                                                       ^
                     |                                                                       |
                     '-----------------------------------------------------------------------+
	


--------------------------------------------------------------------------------
List構造から要素を削除
--------------------------------------------------------------------------------
List構造から要素を削除する場合、list_del()を使用する。
使用方法は、削除対象のList構造(list_head構造体)を引数として渡すだけである。

しかし、削除と言いつつ、ポインタの連結を変更しているだけなので、データ構造が確保していたメモリは解放されない。
そのため、list_del()を呼ぶ前に、データ構造が使用したメモリを解放しなければいけない。


LIST_HEAD(head);       /* 要素の挿入先*/                                                                                  
LIST_HEAD(new_list);   /* 新たに追加したいList構造 */
LIST_HEAD(last_list);  /* 最後尾に追加したいList構造 */
 
list_add_tail(&new_list, &head);  /* headの後ろにnew_listを連結    */
list_add_tail(&last_list, &head); /* headの最後尾にlast_listを連結 */
 
list_del(&last_list);     /* 削除したいList構造のポインタを渡す */






--------------------------------------------------------------------------------
List構造からデータを参照方法
--------------------------------------------------------------------------------
----------------------------------------
list_for_each(pos, head)	//Listを巡回(순회)するマクロ
----------------------------------------
	#define list_for_each(pos, head) \
	        for (pos = (head)->next; pos != (head); pos = pos->next)

	pos:	インジケーターで、最初のアイテム（head->next）を指す
    	head:	listのheader(一番前)で、listのStart Addrである

	posを起点として、最後までloopする。終了条件は、posが再びheadを指している場合。一周したことを表すから。

----------------------------------------
list_entry(ptr,type,member)	//構造体のメンバーのPointerから、その構造体のPointerを取得するマクロ
----------------------------------------
#define list_entry(ptr,type,member)     \				//ptr: メンバーのポインター、即ちstruct list_head型メンバーのポインター
    container_of(ptr, type, member)					//type: prtが所属している構造体の型
									//member: prtが所属している構造体に含まれたstruct list_head型メンバー名
									
	#define container_of(ptr, type, member) ({                      \
	        const typeof( ((type *)0)->member ) *__mptr = (ptr);    \
	               (type *)( (char *)__mptr - offsetof(type,member) );})
	
	#define offsetof(TYPE, MEMBER) ((unsigned int) &((TYPE *)0)->MEMBER)
	
	//offsetof()は、構造の開始Addrに対する構造内のメンバーのアドレスの距離を知るために使用され、
	//container_of()は、メンバーのAddrがわかっている限り、構造の開始アドレスをさらに計算するために使用されます。


--------------------------------------------------------------------------------
従って、2マクロ:
	list_for_each() と
	list_entry   () を
一緒に使用すれば、linked list全体にアクセスできる
--------------------------------------------------------------------------------
	//ex:
	list_for_each(listptr, head) {
		entry = list_entry(listptr, struct My_DATA, list);
		printf("entry->data_1= %d | list addr = %p | next = %p | prev = %p\n", entry->data_1, &entry->list, entry->list.next, entry->list.prev);
	}



--------------------------------------------------------------------------------
list_for_each_entry(pos, head, member)
--------------------------------------------------------------------------------
for文のように、各ノードを順番にアクセスするマクロ

#define list_for_each_entry(pos, head, member)              \
    for (pos = list_entry((head)->next, typeof(*pos), member);   \
         &pos->member != (head);     \
         pos = list_entry(pos->member.next, typeof(*pos), member))

	pos:	インジケーターで、最初のアイテム（head->next）を指す
    	head:	listのheader(一番前)で、listのStart Addrである
	member:	listのnodeのメンバー



--------------------------------------------------------------------------------
include/linux/list.h	API群定義
--------------------------------------------------------------------------------
...
